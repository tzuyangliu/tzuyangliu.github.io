<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>imzyliu&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tzuyangliu.github.io/"/>
  <updated>2017-01-23T15:58:12.000Z</updated>
  <id>http://tzuyangliu.github.io/</id>
  
  <author>
    <name>imzyliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>制作并发布 CocoaPods 库</title>
    <link href="http://tzuyangliu.github.io/2015/11/24/create-and-publish-cocoapods-spec/"/>
    <id>http://tzuyangliu.github.io/2015/11/24/create-and-publish-cocoapods-spec/</id>
    <published>2015-11-23T20:04:03.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着对 CocoaPods 越来越多的依赖，我们也可以尝试把自己的库发布到它上面。本文简要介绍了如何制作并发布自己的 CocoaPods spec<a id="more"></a>。</p><h3 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h3><p>将工程文件提交到代码托管平台如 GitHub，同时打好 tag，比如第一版是 <code>1.0.0</code>，则在 <code>master</code> 分支打一个名为 <code>1.0.0</code> 的 tag。</p><p>一般这里该怎么办都很清楚，我就不赘述了。</p><h3 id="制作并验证-podspec"><a href="#制作并验证-podspec" class="headerlink" title="制作并验证 podspec"></a>制作并验证 podspec</h3><p>首先在自己的工程下使用初始化一个新的 spec，其中 <code>[NAME]</code> 即为库的名称。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec create [NAME]</div></pre></td></tr></table></figure></p><p>之后在该目录下会生成一个 <code>[NAME.podspec]</code> 文件，该文件是 Ruby 编写的，打开并编辑这个文件，把需要填写的基本内容填好如下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></div><div class="line"></div><div class="line">  s.name         = <span class="string">"SHPAlertView"</span></div><div class="line">  s.version      = <span class="string">"1.0.0"</span></div><div class="line">  s.summary      = <span class="string">"A UIAlertView with block support."</span></div><div class="line">  s.homepage     = <span class="string">"https://github.com/tzuyangliu/SHPAlertView"</span></div><div class="line">  s.license      = <span class="string">"MIT"</span></div><div class="line">  s.author       = &#123; <span class="string">"刘子洋"</span> =&gt; <span class="string">"me@zyliu.com"</span> &#125;</div><div class="line">  s.platform     = <span class="symbol">:ios</span>, <span class="string">"7.0"</span></div><div class="line">  s.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://github.com/tzuyangliu/SHPAlertView.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"1.0.0"</span> &#125;</div><div class="line">  s.source_files = <span class="string">"SHPAlertView"</span>, <span class="string">"SHPAlertView/*.&#123;h,m&#125;"</span></div><div class="line">  s.frameworks   = <span class="string">"Foundation"</span>, <span class="string">"UIKit"</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>其中 <code>s.source</code> 中的 tag 即提交代码的时候打的 tag。</p><p>在这里我省略掉了很多注释和不常用的属性，如果需要详细文档请移步 <a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="external">Specs and the Specs Repo</a>。</p><p>保存后进行验证，这一步是无法跳过的，也是为了保证上传的 spec 可用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec lint [NAME]</div></pre></td></tr></table></figure></p><p>如果有错误会有提示，像这样就算成功了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ pod spec lint SHPAlertView.podspec</div><div class="line"></div><div class="line"> -&gt; SHPAlertView (1.0.0)</div><div class="line"></div><div class="line">Analyzed 1 podspec.</div><div class="line"></div><div class="line">SHPAlertView.podspec passed validation.</div></pre></td></tr></table></figure></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>官方文档：<a href="http://guides.cocoapods.org/making/getting-setup-with-trunk.html" target="_blank" rel="external">Getting setup with Trunk</a></p><p>首先注册一个 CocoaPods Trunk 账户，注意将下面的邮箱、姓名与描述替换为自己的信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod trunk register sheep@cocoapods.org <span class="string">'Sheep'</span> --description=<span class="string">'macbook pro'</span></div></pre></td></tr></table></figure></p><p>完成后使用 <code>pod trunk me</code> 检查是否成功，成功后开始上传：</p><p>如果是公开的使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod trunk push [NAME.podspec]</div></pre></td></tr></table></figure></p><p>如果私有则使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod repo push REPO [NAME.podspec]</div></pre></td></tr></table></figure></p><p>看到类似如下的信息，则上传并发布成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ pod trunk push SHPAlertView.podspec </div><div class="line">Updating spec repo `master`</div><div class="line">Validating podspec</div><div class="line"> -&gt; SHPAlertView (1.0.0)</div><div class="line"></div><div class="line">Updating spec repo `master`</div><div class="line">  - Data URL: https://raw.githubusercontent.com/CocoaPods/Specs/2879acf97fcf49a1355c9301f62b96dbd913d702/Specs/SHPAlertView/1.0.0/SHPAlertView.podspec.json</div><div class="line">  - Log messages:</div><div class="line">    - November 23rd, 13:26: Push <span class="keyword">for</span> `SHPAlertView 1.0.0<span class="string">' initiated.</span></div><div class="line"><span class="string">    - November 23rd, 13:26: Push for `SHPAlertView 1.0.0'</span> has been pushed</div><div class="line">    (1.222696649 s).</div></pre></td></tr></table></figure></p><p>可以尝试使用 <code>pod search [NAME]</code> 看看你的库是不是已经出现在里面啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着对 CocoaPods 越来越多的依赖，我们也可以尝试把自己的库发布到它上面。本文简要介绍了如何制作并发布自己的 CocoaPods spec
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>敏捷开发之 Scrum</title>
    <link href="http://tzuyangliu.github.io/2015/11/15/scrum/"/>
    <id>http://tzuyangliu.github.io/2015/11/15/scrum/</id>
    <published>2015-11-14T19:41:22.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在实习的时候接触了 Scrum 开发流程，对于我的团队冰岩作坊来说，有很多可以学习的地方。今天就介绍下 Scrum 开发流程，同时提出了在团队里面实践此方法的思考<a id="more"></a>。</p><h3 id="前言：Why-Scrum"><a href="#前言：Why-Scrum" class="headerlink" title="前言：Why Scrum?"></a>前言：Why Scrum?</h3><p>团队现有的开发方法：瀑布式开发 or 迭代开发？</p><p>*文章很多地方还没完成，只是初稿。</p><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><p>敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。</p><h4 id="以人为核心"><a href="#以人为核心" class="headerlink" title="以人为核心"></a>以人为核心</h4><p>敏捷开发它只写有必要的文档，或尽量少写文档，敏捷开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。</p><h3 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h3><p>Scrum 是一种敏捷开发的方法学，用于迭代式增量软件开发过程。<br>Scrum 一词源于橄榄球运动中的争球。</p><h3 id="Scrum-开发流程的角色"><a href="#Scrum-开发流程的角色" class="headerlink" title="Scrum 开发流程的角色"></a>Scrum 开发流程的角色</h3><h4 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a>产品负责人（Product Owner）</h4><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p><h4 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a>流程管理员（Scrum Master）</h4><p>主要负责整个 Scrum 流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p><h4 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a>开发团队（Scrum Team）</h4><p>主要负责软件产品在 Scrum 规定流程下进行开发工作，人数控制在 5~10 人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到 Sprint 的目标。</p><h3 id="Sprint：冲刺"><a href="#Sprint：冲刺" class="headerlink" title="Sprint：冲刺"></a>Sprint：冲刺</h3><p>Sprint 是 Scrum 的核心，其周期为小于或者等于一个月，其产出是“完成的”、可用的、潜在可发布的产品增量。Sprint 的长度在整个开发过程中保持一致。新的 Sprint 在上一个 Sprint 完成之后立即开始。</p><p>Sprint 由 Sprint 计划会议、每日 Scrum 站会、开发工作、Sprint 评审会议和 Sprint 回顾会议构成。</p><p>每个 Sprint 都可以被视为一个项目，为期不超过一个月。和普通项目一样，Sprint 的目标也是完成一些事情。每个 Sprint 都会定义要开发什么东西，还有一份设计和灵活的计划能够指导开发过程、工作内容和最终结果。</p><p>Sprint 的周期被限制在一个月内。如果 Sprint 周期过长，对“要构建什么东西”的定义就有可能会改变，复杂度和风险也有可能会增加。Sprint 通过确保至少每月一次对达 成目标的进度进行检视和调整，来实现可预见性。Sprint 也把风险限制在一个月的成本上。</p><h3 id="Scrum-的流程"><a href="#Scrum-的流程" class="headerlink" title="Scrum 的流程"></a>Scrum 的流程</h3><p><img src="http://7xkkiq.com1.z0.glb.clouddn.com/scrum-1-new.png" alt=""></p><h4 id="冲刺计划会议（Sprint-Planning）"><a href="#冲刺计划会议（Sprint-Planning）" class="headerlink" title="冲刺计划会议（Sprint Planning）"></a>冲刺计划会议（Sprint Planning）</h4><ol><li>产品负责人根据优先级列需求</li><li>开发团队每个人根据每个需求估算预计完成时间，最后团队根据每个人的预计来确定这项需求需要时间，然后将估计的时间加到总预计完成时间</li><li>当每个人的时间被占满，则不再继续添加需求</li></ol><blockquote><p>关于估算完成时间的方法：<br><img src="http://7xkkiq.com1.z0.glb.clouddn.com/scrum-2.png" alt=""></p></blockquote><p>通过此会议，得到了：</p><ol><li>此次冲刺需要做什么事情</li><li>完成每项事情分别预计需要花费的时间<h4 id="每日站会和开发工作（Daily-Scrum）"><a href="#每日站会和开发工作（Daily-Scrum）" class="headerlink" title="每日站会和开发工作（Daily Scrum）"></a>每日站会和开发工作（Daily Scrum）</h4><h5 id="每日站会"><a href="#每日站会" class="headerlink" title="每日站会"></a>每日站会</h5>参会人员站立开会，任务看板要保证让每个人看到，当每个人发言完后，要走到任务版前更新自己的燃尽图。<h5 id="任务看板与燃尽图"><a href="#任务看板与燃尽图" class="headerlink" title="任务看板与燃尽图"></a>任务看板与燃尽图</h5><img src="http://7xkkiq.com1.z0.glb.clouddn.com/scrum-6.jpeg" alt=""><h4 id="冲刺评审会议（Sprint-demo）"><a href="#冲刺评审会议（Sprint-demo）" class="headerlink" title="冲刺评审会议（Sprint demo）"></a>冲刺评审会议（Sprint demo）</h4>*稍后补充<h4 id="冲刺回顾会议（Sprint-retrospective）"><a href="#冲刺回顾会议（Sprint-retrospective）" class="headerlink" title="冲刺回顾会议（Sprint retrospective）"></a>冲刺回顾会议（Sprint retrospective）</h4>*稍后补充<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4>整个开发时程将依据团队的选择，分为若干个次固定期间的冲刺(Sprint)，期间长度通常介于2~4周之间。每一个冲刺开始前，由产品拥有者与 Scrum 团队会同召开一个冲刺规划会议(Sprint planning)，自产品待办目录中选择若干个故事，由 Scrum 团队一起将选中的每一个故事分割成为数个工作(Task)，将之纪录于该次冲刺的待办目录(Sprint backlog)之中。通常 Sprint planning 的长度以每次不超过4小时为原则。这些工作将由 Scrum 队员领取并在该次冲刺中完成。在当次冲刺即将结束前，由 Scrum 团队对产品拥有者展演已完成的功能及品质特性(Sprint demo)。</li></ol><p>每一个冲刺的最后一项活动为回顾(Sprint retrospective)，由队长主持检讨该次冲刺的好的(Good)与待改进事项(Improvements)。如此周而复始，直到专案结束或完成所有故事。</p><h3 id="附1-Scrum-的实践"><a href="#附1-Scrum-的实践" class="headerlink" title="附1 - Scrum 的实践"></a>附1 - Scrum 的实践</h3><p><a href="http://techblog.youdao.com/?p=373" target="_blank" rel="external">有道云笔记 - 敏捷开发的实战经验</a></p><h3 id="附2-Scrum-如何在冰岩团队内实施"><a href="#附2-Scrum-如何在冰岩团队内实施" class="headerlink" title="附2 - Scrum 如何在冰岩团队内实施"></a>附2 - Scrum 如何在冰岩团队内实施</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>对于团队内一个典型的项目组：</p><ul><li>产品经理（PM）→ 产品负责人（PO）&amp; 客户（？）</li><li>？→ 流程管理员（SM）</li><li>项目组其他成员 → 开发团队（ST）</li></ul><p><img src="http://7xkkiq.com1.z0.glb.clouddn.com/scrum-3-new.png" alt=""><br><img src="http://7xkkiq.com1.z0.glb.clouddn.com/scrum-4.png" alt=""></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>每日站会 -&gt; 每日报告</li><li>冲刺评审会议、冲刺回顾会议 -&gt; 冲刺结束会议</li><li>任务看板：Online</li><li>燃尽图：Online<br><img src="http://7xkkiq.com1.z0.glb.clouddn.com/scrum-5.png" alt=""><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><a href="http://www.scrumguides.org/docs/scrumguide/v1/Scrum-Guide-CN.pdf" target="_blank" rel="external">Scrum Guide</a></li></ul><p><a href="http://scrum.tw/index.php/tw/scrum.html" target="_blank" rel="external">A Simple Intro of Scrum</a></p><p><a href="http://www.cnblogs.com/taven/archive/2010/10/17/1853386.html" target="_blank" rel="external">敏捷开发之Scrum扫盲篇</a></p><p><a href="http://techblog.youdao.com/?p=373" target="_blank" rel="external">敏捷开发的实战经验</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在实习的时候接触了 Scrum 开发流程，对于我的团队冰岩作坊来说，有很多可以学习的地方。今天就介绍下 Scrum 开发流程，同时提出了在团队里面实践此方法的思考
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初探 LivePhoto</title>
    <link href="http://tzuyangliu.github.io/2015/10/24/start-using-livephoto/"/>
    <id>http://tzuyangliu.github.io/2015/10/24/start-using-livephoto/</id>
    <published>2015-10-23T16:36:53.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在装有 iOS 9.0 及以上版本系统的 iPhone 6s / 6s Plus 有一个非常酷炫的特性，在拍照的时候可以选择开启 LivePhoto 功能。如果关闭的话跟以前拍照是一样的，点击拍照按钮会得到一张静态的图片；如果开启这个功能，在拍照的时候会同时在那几秒连拍很多张照片合成一个动图，在相册预览时用力按下去，会播放动图，还伴随有当时的声音<a id="more"></a>。效果如下：</p><p><img src="http://7xkkiq.com1.z0.glb.clouddn.com/start-using-livephoto-1.PNG" alt=""></p><p><em>（关闭 LivePhoto）</em></p><p><img src="http://7xkkiq.com1.z0.glb.clouddn.com/start-using-livephoto-2.PNG" alt=""></p><p><em>（开启 LivePhoto）</em></p><p><img src="http://7xkkiq.com1.z0.glb.clouddn.com/live_photos_camera_2x.png" alt=""></p><p><em>（LivePhoto 效果图，取自 <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/LivePhotos.html" target="_blank" rel="external">Apple Developer</a>）</em></p><p><em>\</em>LivePhoto 播放的效果不太好录制，有机会补上*</p><p>直到 iOS 9.1 发布，开发者才可以通过新的类和 API 在自己的应用中访问相册中的 LivePhoto，这是 Apple 对于在 iOS 9.1 新添加的特性的描述：<a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9_1.html" target="_blank" rel="external">Whats New in iOS 9.1</a>。</p><p>根据描述，开发者可以通过 <code>PHImageManager</code> 拿到 <code>PHLivePhoto</code> 对象，通过 <code>PHLivePhoto</code> 对象提供的属性和方法就可以得到对应的一张 LivePhoto 的完整信息，包括静态图片、动态图片和声音。如果要将这张 LivePhoto 展示给用户，可以通过 <code>PHLivePhotoView</code> 对象来完成。<code>PHLivePhotoView</code> 对象将 LivePhoto 的显示、交互做了完整的封装，还带有用户操作的回调方法。只需把刚才拿到的 <code>PHLivePhoto</code> 对象传递给它，就可以达到跟相册中一样的预览和交互效果。如果要进行分享，可以通过 <code>PHAssetResource</code> 来访问数据。</p><p>关于如何在应用中结合 LivePhoto 带给用户更好的体验，有一篇来自 Apple 的文章：<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/LivePhotos.html" target="_blank" rel="external"> Human Interface Guidelines - Live Photos</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在装有 iOS 9.0 及以上版本系统的 iPhone 6s / 6s Plus 有一个非常酷炫的特性，在拍照的时候可以选择开启 LivePhoto 功能。如果关闭的话跟以前拍照是一样的，点击拍照按钮会得到一张静态的图片；如果开启这个功能，在拍照的时候会同时在那几秒连拍很多张照片合成一个动图，在相册预览时用力按下去，会播放动图，还伴随有当时的声音
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iPhone 接近感应器的坑及解决方案</title>
    <link href="http://tzuyangliu.github.io/2015/09/09/ios-proximity-state-bug-and-solution/"/>
    <id>http://tzuyangliu.github.io/2015/09/09/ios-proximity-state-bug-and-solution/</id>
    <published>2015-09-08T17:28:00.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>实习的时候写公司产品，有个用到接近感应器的功能。就比如打电话，电话接通时开启接近感应器，侦测到接近状态改变（接近/离开）时执行相应的操作——当开启接近感应器时，系统会在接近时熄灭屏幕，离开时再点亮屏幕，等等。但是在这个过程中有bug存在，导致系统接口给的结果不一定是准确的<a id="more"></a>。</p><h3 id="先说理论上的实现"><a href="#先说理论上的实现" class="headerlink" title="先说理论上的实现"></a>先说理论上的实现</h3><p>在 <code>UIKit/UIDevice.h</code> 中的 <code>UIDevice</code> 类（iOS 8.4  SDK），有如下属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,getter=isProximityMonitoringEnabled) BOOL proximityMonitoringEnabled NS_AVAILABLE_IOS(3_0); // default is NO</div><div class="line">@property(nonatomic,readonly)                            BOOL proximityState NS_AVAILABLE_IOS(3_0);  // always returns NO if no proximity detector</div></pre></td></tr></table></figure></p><p><code>proximityMonitoringEnabled</code> 用来标识是否开启接近感应器，如果为 <code>YES</code> 则开启。<code>proximityState</code> 为当前的接近状态，如果为 <code>YES</code> 则为接近（触发），否则为离开（未触发），需要的时候可以直接拿来用。</p><p>以及用于 <code>UINotificationCenter</code> 的键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification NS_AVAILABLE_IOS(3_0);</div></pre></td></tr></table></figure></p><p>于是如果需要在某个地方使用接近感应器，可以注册通知并且开启接近感应器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UIDevice *device = [UIDevice currentDevice];</div><div class="line">[device setProximityMonitoringEnabled:YES];</div><div class="line">if ([device isProximityMonitoringEnabled]) &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                             selector:@selector(proximityStateDidChange:)</div><div class="line">                                                 name:UIDeviceProximityStateDidChangeNotification object:nil];</div><div class="line">&#125;else &#123;</div><div class="line">    NSLog(@&quot;No Proximity Sensor&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后在 <code>-(void)proximityStateDidChange:(BOOL)</code> 方法里面实现需要做的处理。当然记得在不需要的时候取消注册通知、停止接近检测。</p><p>这样看起来是没问题的。</p><h3 id="突然问题来了"><a href="#突然问题来了" class="headerlink" title="突然问题来了"></a>突然问题来了</h3><p>直到有一天发现了一个问题：在已经开启接近检测的情况下，同时触发接近感应器和进入后台（按 Home 键的同时捂住听筒），这样会在熄灭屏幕的情况下进入了后台。手离开听筒，屏幕再次点亮。再进入前台，发现 <code>[UIDevice currentDevice].proximityState</code> 的值为 <code>YES</code> 。也就是说，触发接近感应器的同时进入后台，在后台时离开接近感应器是不会刷新接近状态的（会保持在触发状态）。在这种情况下，系统提供的接口结果不正确。经验证，从 <code>iOS 7</code> 到 <code>iOS 9</code> 都存在这个问题。只有再次触发接近感应器并离开时，才会收到 <code>UIDeviceProximityStateDidChangeNotification</code> 通知，也就是变回正常了。这样看来，<code>UIDevice</code> 的 <code>proximityState</code> 属性也是依赖于上面的通知更新吧。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>好了，既然 <code>iOS</code> 留下了这个 Bug，下面就是如何想办法解决它。对于接近感应器，我们需要的很简单，就是在任何情况下拿到的数据都是真实有效的。有这样一种思路：每次从后台进入前台时，是用户在屏幕亮着并且可操作的情况下进来的，进来之前的瞬间不可能是接近状态。所以在进入前台后到收到接近状态改变的通知前的这段时间，可以推测是非接近状态。</p><p>在这样的思路下，我们就可以做一个简单的接近检测的工具类，添加一个 <code>proximityState</code> 属性，将 <code>get</code> 方法写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)proximityState&#123;</div><div class="line">    if (self.isWaitingProximityStateUpdate) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;else &#123;</div><div class="line">        return [[UIDevice currentDevice] proximityState];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中，<code>isWaitingProximityStateUpdate</code> 表示是否为进入前台后到收到接近状态改变通知前的这段时间。每次进入前台就把这个属性置为 <code>YES</code>，收到接近状态改变通知就置为 <code>NO</code>。</p><p>这样，通过这个工具类的 <code>proximityState</code> 属性，在任何情况下拿到的结果都是真实有效的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习的时候写公司产品，有个用到接近感应器的功能。就比如打电话，电话接通时开启接近感应器，侦测到接近状态改变（接近/离开）时执行相应的操作——当开启接近感应器时，系统会在接近时熄灭屏幕，离开时再点亮屏幕，等等。但是在这个过程中有bug存在，导致系统接口给的结果不一定是准确的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift 学习笔记</title>
    <link href="http://tzuyangliu.github.io/2015/08/07/swift-for-the-really-impatient-note/"/>
    <id>http://tzuyangliu.github.io/2015/08/07/swift-for-the-really-impatient-note/</id>
    <published>2015-08-06T16:27:00.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天入手了《 Swift for the Really Impatient 》，中文名《写给大忙人看的 Swift 》，基于 Swift 1.2 介绍了如何使用 Swift 以及利用它的优秀特性。<br>从 Swift 1.0 发布，到现在 Swift 2.0 马上面世（*），笔者使用 Swift 的思路还停留在跟使用 Objective-C 一样的层次——换句话说，没怎么用到过 Swift 新的特性。蛮喜欢这本书，顺着读的过程写下读书笔记，方便以后回顾，也可以跟大家一起分享<a id="more"></a>。</p><p>接下来要写的内容不会是所有Swift语法的罗列，<strong>是从 Objective-C 转到 Swift 需要了解的新特性。</strong></p><h3 id="第1章-Swift-介绍"><a href="#第1章-Swift-介绍" class="headerlink" title="第1章 Swift 介绍"></a>第1章 Swift 介绍</h3><h4 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h4><h5 id="1-1-1-变量和常量"><a href="#1-1-1-变量和常量" class="headerlink" title="1.1.1 变量和常量"></a>1.1.1 变量和常量</h5><p>在 Objective-C 中，由类型本身决定其是否可变，例如 <code>NSArray</code> 和 <code>NSMutableArray</code>；在 Swift 中，对象的可变与与不可变版本具有相同的类型，而不是子类的关系。</p><blockquote><p>Swift 的基本数据结构有：枚举（enum）、结构体（struct）和类（class）。枚举或结构体在代码中是传值的，类是传引用。</p></blockquote><p>像 <code>Int</code> 这种基本数据类型都是基于结构体实现的，所以它们可能会通过属性和方法实现一些额外的功能，这在 Objective-C 是没有的。</p><p>Swift 是一门强类型语言，在编译期就需要确定变量的类型；任何一个类型都不能隐式转换成另一个类型，所以要在写代码时对类型额外留意；无论是通过明确指定变量类型，如 <code>var appleCount: Int</code>，还是通过类型推断来指定变量类型，如 <code>var appleCount = 0</code>，指明类型都是必要的。</p><h5 id="1-1-2-字符串插值"><a href="#1-1-2-字符串插值" class="headerlink" title="1.1.2 字符串插值"></a>1.1.2 字符串插值</h5><p>下面代码就能表达清楚 Swift 的字符串插值，当然字符串插值不仅仅可以用于 <code>println()</code> 方法，任何字符串都可以。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> appleCount = <span class="number">99</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"There are <span class="subst">\(appleCount)</span> apples in your bag"</span>)</div></pre></td></tr></table></figure></p><h5 id="1-1-3-流程控制"><a href="#1-1-3-流程控制" class="headerlink" title="1.1.3 流程控制"></a>1.1.3 流程控制</h5><h6 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h6><p>Swift 提供了 <code>if</code> 和 <code>switch</code> 两种语法结构。</p><p>对于 <code>if</code>，用法跟 Objective-C 基本一致，只是条件不是必须要用括号括住了，如使用以下方法是合理的，当然加上括号也没问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if appleCount &gt; 0 &#123;</div><div class="line">// do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于 <code>switch</code>，跟 Objective-C 不同的是，当遇到下一个 <code>case</code> 分支开始时，<code>switch</code> 语句会自动结束。也就是说，不需要在每个 <code>case</code> 最后使用 <code>break</code> 了。当然如果需要，可以使用 <code>fallthrough</code> 关键字。下面是用法的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var appleCount: Int = calcAppleCount()</div><div class="line">switch appleCount &#123;</div><div class="line">case 0:</div><div class="line">    println(&quot;No apple left.&quot;)</div><div class="line">case 1:</div><div class="line">    println(&quot;One apple a day, keep doctor away.&quot;)</div><div class="line">default:</div><div class="line">    println(&quot;I have \(appleCount) apples!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h6 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h6><p><code>for</code> 循环用法与 Objective-C 相近，除了也是可以不需要括号。比较有意思的是 <code>for-in</code>，Swift 提供了两种新的区间运算符：左开右闭区间 <code>..&lt;</code>，闭区间 <code>...</code>，如下面两种用法是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i in 0 ..&lt; 10 &#123;</div><div class="line">// do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i in 0 ... 9 &#123;</div><div class="line">// do something</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Swift 2 添加了 <code>.forEach</code> 方法，可以结合链式操作使用，效果与上面等同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(0 ..&lt; 10).forEach &#123;</div><div class="line">// do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>跟 Objective-C 一样，可以使用 <code>break</code> 和 <code>continue</code> 控制循环。Swift 针对这一点增加了一个强大的功能：给循环语句添加标签（<code>label</code>），然后在内部循环中指定希望 <code>break</code> 或 <code>continue</code> 到哪个循环中。一个标签由名称之后跟着一个冒号构成，并且标签位于循环语句关键字之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var bags: [Bag] = currentBags()</div><div class="line">first: for bag in bags &#123;</div><div class="line">    second: for apple in bag.apples &#123;</div><div class="line">        if somethingHappend &#123;</div><div class="line">            break first</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="1-2-基本数据类型"><a href="#1-2-基本数据类型" class="headerlink" title="1.2 基本数据类型"></a>1.2 基本数据类型</h4><h5 id="1-2-1-整型"><a href="#1-2-1-整型" class="headerlink" title="1.2.1 整型"></a>1.2.1 整型</h5><p>之前提到，在 Swift 中像 <code>Int</code> 这些基本数据类型都是结构体，有兴趣可以去看 <code>Int</code> 的头文件。<code>Int</code> 有一些静态属性，比如 <code>min</code> 和 <code>max</code> 属性。<code>Int</code> 在 32 位设备中表现为 32 位整型，在 64 位设备中表现为 64 位整型。</p><p>需要特定长度的整型时，可以使用 <code>Int8</code>、<code>Int16</code>、<code>Int32</code> 或 <code>Int64</code>（无符号版本在前面加个 U 前缀即可：<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code> 或 <code>UInt64</code>）。</p><p>关于类型转换可以使用如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a32BitInt: Int32 = 1</div><div class="line">var a64BitInt: Int64 = Int64(a32BitInt)</div></pre></td></tr></table></figure></p><p>但是可能会有潜在的溢出风险。比如将一个 <code>Int64.max</code> 使用 <code>Int32()</code> 方法得到的结果是溢出的，而编译器暂时还不能捕获这种情况。</p><blockquote><p>为了确保兼容性，写到文件的整型变量都应指明长度，防止出现 32 位设备保存的值被 64 位设备直接读取产生错误。</p></blockquote><h5 id="1-2-2-Double-和-Float"><a href="#1-2-2-Double-和-Float" class="headerlink" title="1.2.2 Double 和 Float"></a>1.2.2 Double 和 Float</h5><p>使用小数时，编译器类型推断默认为 <code>Double</code>。<code>Double</code> 和 <code>Float</code> 都有一些有用的属性，比如 <code>NaN</code>、<code>infinity</code> 等。</p><h5 id="1-2-3-布尔型"><a href="#1-2-3-布尔型" class="headerlink" title="1.2.3 布尔型"></a>1.2.3 布尔型</h5><p>Swift 使用 <code>true</code> 和 <code>false</code> 来表示是与否。只有表达式显式地返回一个布尔类型才能被用于布尔值的声明，所以在代码中不能将布尔值与 0 或 nil 隐式比较，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var someInteger = 0</div><div class="line">var hasSome: Bool = (someInteger != 0)</div><div class="line">// hasSome: false</div></pre></td></tr></table></figure></p><h5 id="1-2-4-字符串"><a href="#1-2-4-字符串" class="headerlink" title="1.2.4 字符串"></a>1.2.4 字符串</h5><p>Swift 中的字符串是 <code>String</code>，<code>String</code> 是 <code>Character</code> 类型值的集合。<br>使用 <code>+</code> 运算符可以将字符串拼接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var prefix = &quot;123&quot;</div><div class="line">var suffix = &quot;456&quot;</div><div class="line">var fullString = prefix + suffix</div><div class="line">// fullString: &quot;123456&quot;</div></pre></td></tr></table></figure></p><p>也可以使用 <code>+=</code> 运算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;123&quot;</div><div class="line">var suffix = &quot;456&quot;</div><div class="line">string += suffix</div><div class="line">// string: &quot;123456&quot;</div></pre></td></tr></table></figure></p><p>由于 <code>String</code> 是 <code>Character</code> 的集合，可以用 <code>for-in</code> 循环语句对其进行迭代。</p><p>可以直接使用 <code>==</code> 来比较两个字符串值是否相同。</p><h5 id="1-2-5-数组"><a href="#1-2-5-数组" class="headerlink" title="1.2.5 数组"></a>1.2.5 数组</h5><p>声明数组可以使用长形式和短形式，不过既然有短形式为何还要用长形式。</p><p>长形式：<code>Array&lt;ValueType&gt;</code></p><p>短形式：<code>[ValueType]</code></p><p>利用短形式声明和初始化一个数组的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var apple: [String] = [] // 显式类型</div><div class="line">var apple = [String]()   // 隐式类型</div></pre></td></tr></table></figure></p><p>关于数组，得益于 Swift 基本数据类型是结构体，数组可以存储结构体，所以可以直接将基本数据类型存到数值，而 Objective-C 是不行的。存到数组中的元素，传值与传引用的性质与 Objective-C 相似。</p><h5 id="1-2-6-字典"><a href="#1-2-6-字典" class="headerlink" title="1.2.6 字典"></a>1.2.6 字典</h5><p>声明字典也有两种形式</p><p>长形式：<code>Dictionary&lt;KeyType, ValueType&gt;</code></p><p>短形式：<code>[KeyType: ValueType]</code></p><p>利用短形式声明和初始化一个字典的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var apple: [String: SomeClass] = [:] // 显式类型</div><div class="line">var apple = [String: SomeClass]()    // 隐式类型</div></pre></td></tr></table></figure></p><p>在代码中可以使用遵循 <code>Hashable</code> 协议的任意类型当做字典的 KeyType 值。</p><p>由于字典也是集合，可以用 <code>for-in</code> 循环语句对其进行迭代。</p><h3 id="第二章-深入学习-Swift-语法"><a href="#第二章-深入学习-Swift-语法" class="headerlink" title="第二章 深入学习 Swift 语法"></a>第二章 深入学习 Swift 语法</h3><p>强烈推荐之前没有用过 Swift 的同学看一下这部分。这里列举的一些很酷的特性足够让你找到充分的从 Objective-C 转到 Swift 的理由。</p><h4 id="2-1-可空类型"><a href="#2-1-可空类型" class="headerlink" title="2.1 可空类型"></a>2.1 可空类型</h4><p>Swift 提供了可空类型来处理变量可能为空的情况。可空类型能够安全地检查某个值是否为空，当值不为空时，才会被访问。</p><p>可空类型有两种不同的表达方式：<code>Some</code> 或者 <code>None</code>。值不为空时，可空类型用 <code>Optional.Some(value)</code> 表示，否则用 <code>Optional.None</code> 表示。</p><p>在类型后面添加一个 <code>?</code> 修饰符即可将变量声明为可空类型。例如 <code>String?</code>，任何类型都可以修饰为可空类型。访问可空类型的值必需要进行拆箱（unwrap），即在变量名后添加一个 <code>!</code>，例如<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstName: <span class="type">String</span>?</div><div class="line"><span class="comment">// firstName被修饰为可空类型</span></div><div class="line"><span class="keyword">let</span> fullName = <span class="string">"Sheep"</span> + firstName!</div><div class="line"><span class="comment">// 无法直接使用firstName，使用时需要进行拆箱，即使用firstName!</span></div></pre></td></tr></table></figure></p><p>如果对一个不存在的值强行拆箱，面临的将是崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let sheep = dict[&quot;Animal&quot;]</div><div class="line">// sheep被推断为可空类型，假设sheep不存在</div><div class="line">let sheepString = sheep!</div><div class="line">// 崩溃：不能对Optional.None进行拆箱</div></pre></td></tr></table></figure></p><p>可空类型让我们必须处理值可能为空的情况，而且 Swift 强制规定不允许在非可空类型（即普通的类型）中存储空值，所以非可空类型不允许为空。这跟任何地方都可能为 <code>nil</code> 的 Objective-C 是不同的。给一个非可空类型赋空值会导致编译器报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name = &quot;sheep&quot;</div><div class="line">name = nil</div><div class="line">// 编译错误</div></pre></td></tr></table></figure></p><p>在这样的设定下，之前使用 Objective-C 几乎所有因为空值导致的问题都可以在编译期被发现并及时改正。</p><p>之前提到，对一个空的可空类型强制拆箱会导致崩溃。所以可空类型拆箱前需要检查是否为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var sheep = dict[&quot;Animal&quot;]</div><div class="line">if sheep != nil &#123;</div><div class="line">    let validSheep = sheep!</div><div class="line">    println(validSheep)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Swift 提供了一种将检查和拆箱操作合并到一个步骤的语法，即<strong>可空绑定</strong>。如上面的代码可以被可空绑定替换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var sheep = dict[&quot;animal&quot;]</div><div class="line">if let validSheep = sheep &#123;</div><div class="line">    println(validSheep)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>关于可空类型的使用，将在后面的笔记中进一步讨论。</p><h4 id="2-2-泛型"><a href="#2-2-泛型" class="headerlink" title="2.2 泛型"></a>2.2 泛型</h4><p>像 Java、C# 等语言都有一个非常好用的特性：泛型。这个特性Objective-C 是在 <a href="https://github.com/tomersh/Objective-C-Generics" target="_blank" rel="external">2015 年 6 月才支持的</a>，Swift 一直支持这样的特性。我们可以使用泛型创建善于表达的、可重用的、类型安全的代码。</p><p>举个最简单的例子，当你实现一个取两个整型较大值的函数时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func maxInt(a: Int, b: Int) -&gt; Int &#123;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        return a</div><div class="line">    &#125;else&#123;</div><div class="line">        return b</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>后来你又需要取两个浮点型的较大值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func maxFloat(a: Float, b: Float) -&gt; Float &#123;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        return a</div><div class="line">    &#125;else&#123;</div><div class="line">        return b</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果还有 <code>Double</code> 等等，就会多写很多重复的代码。而且如果逻辑改变，每个函数都要去修改，显然不是一个很好的实现。此时泛型提供了一个很好的解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func maxValue&lt;T: Comparable&gt;(a: T, b: T) -&gt; T &#123;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        return a</div><div class="line">    &#125;else&#123;</div><div class="line">        return b</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样写的意思是：声明了一个名为 <code>maxValue</code> 的函数，在参数列表前的 <code>&lt;T: Comparable &gt;</code> 表明这是一个泛型函数。<code>&lt;T: Comparable&gt;</code> 告诉编译器，此函数使用一个遵循 <code>Comparable</code> 协议的泛型 <code>T</code>，当函数被调用时 <code>T</code> 将被具体的类型所替换。其实不同的类型调用会产生不同的函数，这件事情是编译器来完成的（笔者猜也有运行时的功劳吧）。</p><p>Swift 标准库的 <code>Array</code> 和 <code>Dictionary</code> 等类和许多函数都使用了泛型。以下是 <code>Array</code> 在标准库（Swift 1.2）中的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct Array&lt;T&gt; : MutableCollectionType, Sliceable, _DestructorSafeContainer</div></pre></td></tr></table></figure></p><p>当数组创建后，数组的类型就被指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let animals = [&quot;WhiteSheep&quot;, &quot;BlackSheep&quot;, &quot;RedSheep&quot;]</div><div class="line">// animals: [String]</div><div class="line">animals.append(233)</div><div class="line">// 编译器错误：无法赋值，只能接受String</div></pre></td></tr></table></figure></p><p>所以使用泛型可以将类型造成的问题在编译期就发现并解决。</p><h4 id="2-3-类型声明和类型推断"><a href="#2-3-类型声明和类型推断" class="headerlink" title="2.3 类型声明和类型推断"></a>2.3 类型声明和类型推断</h4><p>之前也提到了，Swift 可以根据提供的信息来推断类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dict = [&quot;animal&quot;: 233]</div><div class="line">// 编译器推断：dict: Dictionary&lt;String, Int&gt;</div></pre></td></tr></table></figure></p><p>但如果提供的信息不足，那么编译器也无法确定是哪种类型，这时候就需要手动指明类型了。</p><h4 id="2-4-函数和闭包"><a href="#2-4-函数和闭包" class="headerlink" title="2.4 函数和闭包"></a>2.4 函数和闭包</h4><p>Swift 中的闭包与 Objective-C 中的 Block 相似，使用上更加灵活。Swift 中的闭包有三种形式：全局函数、嵌套函数、闭包表达式。</p><h5 id="2-4-1-全局函数"><a href="#2-4-1-全局函数" class="headerlink" title="2.4.1 全局函数"></a>2.4.1 全局函数</h5><p>这是最普遍的一种闭包，直接举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func globalFunction() &#123;</div><div class="line">// Do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="2-4-2-嵌套函数"><a href="#2-4-2-嵌套函数" class="headerlink" title="2.4.2 嵌套函数"></a>2.4.2 嵌套函数</h5><p>函数可以嵌套至别的函数内部。嵌套函数无法从声明此函数上下文的外部调用，但嵌套函数可以被容器函数以返回值的形式暴露给外部。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func animalMaker(animal: String) -&gt; (String -&gt; String) &#123;</div><div class="line">    func animalMakeFunc(name: String) -&gt; String &#123;</div><div class="line">        return &quot;\(animal), \(name)&quot;</div><div class="line">    &#125;</div><div class="line">    return animalMakeFunc</div><div class="line">&#125;</div><div class="line">var sheepAnimal = animalMaker(&quot;Sheep&quot;)</div><div class="line">let aSheep = sheepAnimal(&quot;Timmy&quot;)</div><div class="line">println(aSheep)</div><div class="line">// &quot;Sheep, Timmy&quot;</div><div class="line">var sharkAniaml = animalMaker(&quot;Shark&quot;)</div><div class="line">let aShark = sharkAniaml(&quot;Dave&quot;)</div><div class="line">println(aShark)</div><div class="line">// &quot;Shark, Dave&quot;</div></pre></td></tr></table></figure></p><h5 id="2-4-3-闭包表达式"><a href="#2-4-3-闭包表达式" class="headerlink" title="2.4.3 闭包表达式"></a>2.4.3 闭包表达式</h5><p>闭包表达式提供了一种轻量级的隔离代码的方法，同时从上下文捕获值。下面是一个闭包表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1, 2, 3]</div><div class="line">var squares = numbers.map(&#123;(num: Int) -&gt; Int in</div><div class="line">    return num * num</div><div class="line">&#125;)</div><div class="line">// squares = [1, 4, 9]</div></pre></td></tr></table></figure></p><p>可以看出，闭包表达式使用了和全局函数及嵌套函数类似的语法。在一对大括号间，我们定义了一个参数列表，一个返回类型，一个<code>in</code>关键字，以及闭包中所包含的Swift语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; (parameters) -&gt; return type in</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>更多细节将在后面的读书笔记完成后，在此开传送门</p><h4 id="2-5-元组"><a href="#2-5-元组" class="headerlink" title="2.5 元组"></a>2.5 元组</h4><p>Swift 中的元组是我刚开始接触这门语言就知道的数据结构，可以把多个值结合成一个单个的对象。当时惊呼好爽，这意味着可以抛弃那些单纯为了数据存储而写的类，灵活自由，而且类型安全。</p><p>创建一个元组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let animal = (&quot;sheep&quot;, &quot;male&quot;, 21)</div><div class="line">// animal: (String, String, Int)</div></pre></td></tr></table></figure></p><p>访问元组的成员，有几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">println(&quot;\(animal.0), \(animal.1), \(animal.2)&quot;)</div><div class="line">// 输出：&quot;sheep, male, 21&quot;</div><div class="line">// 或</div><div class="line">let (name, sex, age) = animal</div><div class="line">println(&quot;\(name), \(sex), \(age)&quot;)</div><div class="line">// 输出：&quot;sheep, male, 21&quot;</div></pre></td></tr></table></figure></p><p>创建元组时也可以直接给成员命名以方便访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let sheep = (name: &quot;sheep&quot;, sex: &quot;male&quot;, age: 21)</div><div class="line">println(&quot;\(sheep.name), \(sheep.sex), \(sheep.age)&quot;)</div><div class="line">// 输出：&quot;sheep, male, 21&quot;</div></pre></td></tr></table></figure></p><p>可以将函数的返回值声明为元组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func numberCounts(nums: [Int]) -&gt; (Int, Int) &#123;</div><div class="line">    var evenCount = 0</div><div class="line">    var oddCount = 0</div><div class="line">    for number in nums &#123;</div><div class="line">        if number % 2 == 0 &#123;</div><div class="line">            evenCount += 1</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            oddCount += 1</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return (evenCount, oddCount)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这是一个统计奇偶数数量的函数，返回值是个元组，可以这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let numbers = [1, 2, 3, 4, 5, 6]</div><div class="line">let counts = numberCounts(numbers)</div><div class="line">// counts = (3, 3)</div></pre></td></tr></table></figure></p><p>如果不需要元组中的某个值，可以使用下划线 <code>_</code> 替代，这样在分解时，编译器会忽略该值。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let sheep = (&quot;sheep&quot;, &quot;male&quot;, 21)</div><div class="line">let (_, sex, _) = sheep</div><div class="line">println(&quot;\(sex)&quot;)</div><div class="line">// 输出：male</div></pre></td></tr></table></figure></p><p>元组提供了一种轻量级的、灵活的数据建模方式，在使用上更加简单，数据结构的阐述更加自然。</p><h4 id="2-6-switch-语句和模式匹配"><a href="#2-6-switch-语句和模式匹配" class="headerlink" title="2.6 switch 语句和模式匹配"></a>2.6 switch 语句和模式匹配</h4><p>Swift 的 <code>switch</code> 语句与 Objective-C 相比，更加强大、灵活和安全，可以利用模式匹配提供更加灵活的代码。另外，之前提到过，为了减少不必要的错误，<code>case</code> 语句不再提供自动贯穿的功能，而且所有可能的值都必须在 <code>case</code> 语句中列出。</p><p><code>case</code> 语句可以匹配值、范围、模式并进行值绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">let httpStatusCode = 404</div><div class="line"></div><div class="line">switch httpStatusCode &#123;</div><div class="line">case 100...199:</div><div class="line">    println(&quot;information status&quot;)</div><div class="line">case 200...299:</div><div class="line">    println(&quot;success status&quot;)</div><div class="line">case 300...399:</div><div class="line">    println(&quot;redirection status&quot;)</div><div class="line">case 400...499:</div><div class="line">    println(&quot;client error status&quot;)</div><div class="line">case 500...599:</div><div class="line">    println(&quot;server error status&quot;)</div><div class="line">default:</div><div class="line">    println(&quot;not a valid code&quot;)</div><div class="line">&#125;</div><div class="line">// 输出：&quot;client error status&quot;</div></pre></td></tr></table></figure></p><p><code>switch</code> 语句可以与元组结合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let animal = (name:&quot;sheep&quot;, sex:&quot;male&quot;, age:21)</div><div class="line"></div><div class="line">switch animal &#123;</div><div class="line">case (&quot;sheep&quot;, _, _):</div><div class="line">    println(&quot;I like sheep, it&apos;s a cool animal&quot;)</div><div class="line">case (_, _, 21):</div><div class="line">    println(&quot;This animal has same age with me&quot;)</div><div class="line">case (_, &quot;female&quot;, 0...18):</div><div class="line">    println(&quot;It&apos;s a young lady&quot;)</div><div class="line">default:</div><div class="line">    println(&quot;\(animal.name), \(animal.sex), \(animal.age)&quot;)</div><div class="line">&#125;</div><div class="line">// 输出：&quot;I like sheep, it&apos;s a cool animal&quot;</div></pre></td></tr></table></figure></p><p>在 <code>case</code> 中还可以使用 <code>where</code> 子句，结合值绑定，Swift 中 <code>switch</code> 语句的表达力和功能已经远超过 Objective-C 的 <code>switch</code> 语句了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let indexSizeAndValue = (5, 6, &quot;&quot;)</div><div class="line"></div><div class="line">switch indexSizeAndValue &#123;</div><div class="line">case (0, _ , let value):</div><div class="line">    println(&quot;The first value is \(value)&quot;)</div><div class="line">case let (index, size, &quot;&quot;) where index == (size - 1):</div><div class="line">    println(&quot;The last value is empty&quot;)</div><div class="line">case let (index, size, value) where index == (size - 1):</div><div class="line">    println(&quot;The last value is \(value)&quot;)</div><div class="line">case let (index, _, value):</div><div class="line">    println(&quot;The value at index \(index) is \(value)&quot;)</div><div class="line">&#125;</div><div class="line">// 输出：&quot;The last value is empty&quot;</div></pre></td></tr></table></figure></p><p>这段代码没有 <code>default</code> 语句因为最后一个 <code>case</code> 已经包含了所有剩下的情况。</p><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><ul><li>Swift 2 已经发布正式版<h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><img src="http://7xkkiq.com1.z0.glb.clouddn.com/Swift-for-the-really-impatient.jpg" alt=""></li></ul><p>本文多数内容与思路来源于《 Swift for the Really Impatient 》，原作者为 [美] Matt Henderson 和 Dave Wood。如有侵权，请及时联系笔者删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天入手了《 Swift for the Really Impatient 》，中文名《写给大忙人看的 Swift 》，基于 Swift 1.2 介绍了如何使用 Swift 以及利用它的优秀特性。&lt;br&gt;从 Swift 1.0 发布，到现在 Swift 2.0 马上面世（*），笔者使用 Swift 的思路还停留在跟使用 Objective-C 一样的层次——换句话说，没怎么用到过 Swift 新的特性。蛮喜欢这本书，顺着读的过程写下读书笔记，方便以后回顾，也可以跟大家一起分享
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Ghost 搭建博客</title>
    <link href="http://tzuyangliu.github.io/2015/07/23/make-a-blog-with-ghost/"/>
    <id>http://tzuyangliu.github.io/2015/07/23/make-a-blog-with-ghost/</id>
    <published>2015-07-23T06:06:00.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>类似于 WordPress、Hexo 等，Ghost 也是一个非常方便用来搭建个人网站、博客的开源框架，基于 Node.js<a id="more"></a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>来自 <a href="https://ghost.org" target="_blank" rel="external">Ghost</a> 网站的介绍</p><blockquote><p>Ghost is a simple, powerful publishing platform that allows you to share your stories with the world.</p><p>Ghost是一个简洁而强大的发布平台，帮助你与世界分享自己的故事。</p></blockquote><p>*此博客使用 Ghost 搭建。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Ghost 有区分本地环境和生产环境，下面写的是针对 Ubuntu 14.04 服务器生产环境的安装与配置。</p><h4 id="更新-Ubuntu"><a href="#更新-Ubuntu" class="headerlink" title="更新 Ubuntu"></a>更新 Ubuntu</h4><p>为了保证后面安装顺利，推荐先进行更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get upgrade -y</div><div class="line">sudo aptitude install -y zip vim wget</div></pre></td></tr></table></figure></p><h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>需要 Node v0.10.x - v0.12.x，用 <code>node -v</code> 和 <code>npm -v</code> 查看是否已经安装了需要的 Node 和 npm ，如果满足条件则可以直接跳到下一步。</p><p>配置 Ubuntu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl --silent --location https://deb.nodesource.com/setup_0.12 | sudo bash -</div></pre></td></tr></table></figure></p><p>安装 Node.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install --yes nodejs</div></pre></td></tr></table></figure></p><p>其他系统平台可以参考 <a href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager" target="_blank" rel="external">Installing-Node.js-via-package-manager</a></p><h4 id="安装-Ghost"><a href="#安装-Ghost" class="headerlink" title="安装 Ghost"></a>安装 Ghost</h4><p>下载最新版的 Ghost<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -L https://ghost.org/zip/ghost-latest.zip -o ghost.zip</div></pre></td></tr></table></figure></p><p>将下载的文件解压到 <code>/var/www/ghost</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unzip -uo ghost.zip -d /var/www/ghost</div></pre></td></tr></table></figure></p><p>去对应文件夹进行安装，因为是生产环境，所以只需要安装生产环境的依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd /var/www/ghost &amp;&amp; npm install --production</div></pre></td></tr></table></figure></p><p>至此 Ghost 已经安装完成</p><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p>使用提供的 <code>config.example.js</code> 来生成配置文件并编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo cp config.example.js config.js</div><div class="line">$ sudo vim config.js</div></pre></td></tr></table></figure></p><p>在 <code>Production</code> 一栏将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host: &apos;127.0.0.1&apos;</div></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host: &apos;0.0.0.0&apos;</div></pre></td></tr></table></figure></p><p>再对里面的域名做相应的修改，如笔者的域名为 zyliu.com<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url: &apos;zyliu.com&apos;</div></pre></td></tr></table></figure></p><p>保存并退出，其他配置可以参考<a href="http://support.ghost.org/config/" target="_blank" rel="external">官方配置文档</a></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm start --production</div></pre></td></tr></table></figure><p>至此 Ghost 已经完成初始配置并已启动，监听 <code>2368</code> 端口</p><p>通过 <code>http://&lt;your-ip-address&gt;:2368</code> 访问主页</p><p>通过 <code>http://&lt;your-ip-address&gt;:2368/ghost</code> 来创建管理员用户和设置网站</p><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p><code>npm start --production</code> 命令不能在后台执行，所以这里需要 <code>forever</code> 的支持。</p><h4 id="安装forever"><a href="#安装forever" class="headerlink" title="安装forever"></a>安装forever</h4><p>首先安装 <code>forever</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install forever -g</div></pre></td></tr></table></figure></p><p>在 <code>/var/www/ghost</code> 目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ NODE_ENV=production forever start index.js</div></pre></td></tr></table></figure></p><p>就可以后台运行了。停止的话，在相同目录执行以下命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ forever stop index.js</div></pre></td></tr></table></figure></p><p>当然可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ alias ghost_restart=&quot;cd /var/www/ghost; forever stop index.js; NODE_ENV=production forever start index.js;&quot;</div></pre></td></tr></table></figure></p><p>然后在任意目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ghost_restart</div></pre></td></tr></table></figure></p><p>就可以重启 Ghost 服务了</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>为了服务器安全不建议在配置文件里直接将 <code>port</code> 修改为 <code>80</code>。如果需要将Ghost绑定到 <code>80</code> 端口，使用 Nginx 做个反向代理即可</p><p>安装 Nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install nginx -y</div></pre></td></tr></table></figure></p><p>Nginx 的配置文件在 <code>/etc/nginx/conf.d/</code>，现在前往这个文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd /etc/nginx/conf.d/</div></pre></td></tr></table></figure></p><p>新建一个配置文件，格式可以为 <code>DOMAIN-NAME.conf</code>，如笔者的网站是 zyliu.com，则配置文件名为 <code>zyliu.com.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim DOMAIN-NAME.conf</div></pre></td></tr></table></figure></p><p>填写如下内容，将其中的 <code>DOMAIN-NAME</code> 替换为自己的域名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    server_name DOMAIN-NAME;</div><div class="line">    location / &#123;</div><div class="line">        proxy_set_header   X-Real-IP $remote_addr;</div><div class="line">        proxy_set_header   Host      $http_host;</div><div class="line">        proxy_pass         http://127.0.0.1:2368;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重启 Nginx 服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service nginx restart</div></pre></td></tr></table></figure></p><p>现在就可以通过 <code>http://&lt;your-ip-address&gt;</code> 来访问主页了</p><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>以下是笔者想到的部分日常需求和解决方案</p><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>对 <code>/var/www/ghost</code> 文件夹使用 Git 进行版本控制，同时满足了备份的要求。Git 仓库的选择，国外可以使用 GitHub，国内可以使用 Coding、GitCafe 等服务，来保证速度。</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>Ghost 的主题安装在 <code>/var/www/ghost/content/themes</code>，每个主题以一个独立的文件夹形式存在，关于如何制作主题详见<a href="http://ghost.diancloud.com/doc/zh/themes/" target="_blank" rel="external">如何制作 Ghost 主题</a>，里面有主题的格式与规范。</p><p>也可以从<a href="http://marketplace.ghost.org" target="_blank" rel="external">官方主题商店</a>购买主题（也有免费的），将主题下载到主题文件夹内解压，然后重启 Ghost 服务即可在网页设置里面看到。</p><p>如果要修改主题，可以在每个主题文件夹里使用 Git 与线上仓库进行同步，每次仓库有更新可以通过 <code>git pull</code> 命令来更新线上主题。我为此写了一个更新主题的脚本如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">theme_path=&quot;/var/www/ghost/content/themes/&quot;;</div><div class="line">echo &quot;定位到$theme_path&quot;;</div><div class="line">cd $theme_path;</div><div class="line">for dir in `ls .`</div><div class="line"> do</div><div class="line">   if [ -d $dir ]</div><div class="line">   then</div><div class="line">     cd $dir</div><div class="line">        if [ -d &quot;.git&quot; ]</div><div class="line">        then</div><div class="line">        echo &quot;正在更新主题$&#123;dir&#125;&quot;;</div><div class="line">        git pull origin master;</div><div class="line">        echo &quot;主题$&#123;dir&#125;更新成功&quot;;</div><div class="line">        else</div><div class="line">        echo &quot;WARNING: 主题$&#123;dir&#125;不是git目录，无法更新&quot;;</div><div class="line">        fi</div><div class="line">     cd ..</div><div class="line">   fi</div><div class="line">done</div><div class="line">echo &quot;所有主题更新完成&quot;;</div></pre></td></tr></table></figure></p><p>将此脚本命名为 <code>ghost_theme_update.sh</code> 存至 <code>/var/www/ghost</code><br>，然后在此目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x ghost_theme_update.sh</div></pre></td></tr></table></figure></p><p>现在就可以使用以下命令更新主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd /var/www/ghost &amp;&amp; ./ghost_theme_update.sh</div></pre></td></tr></table></figure></p><p>还可以将此命令设为 <code>alias</code> 方便访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ alias ghost_theme_update=&quot;cd /var/www/ghost; ./ghost_theme_update.sh&quot;</div></pre></td></tr></table></figure></p><p>之后在任何地方执行以下命令即可自动更新主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ghost_theme_update</div></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://ghost.org" target="_blank" rel="external">Ghost</a></p><p><a href="http://support.ghost.org/installing-ghost-linux/" target="_blank" rel="external">Installing Ghost on Linux</a></p><p><a href="https://allaboutghost.com/how-to-proxy-port-80-to-2368-for-ghost-with-nginx/" target="_blank" rel="external">How to Proxy Port 80 to 2368 for Ghost with Nginx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类似于 WordPress、Hexo 等，Ghost 也是一个非常方便用来搭建个人网站、博客的开源框架，基于 Node.js
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 计时的实现</title>
    <link href="http://tzuyangliu.github.io/2015/04/19/timer-in-ios/"/>
    <id>http://tzuyangliu.github.io/2015/04/19/timer-in-ios/</id>
    <published>2015-04-18T19:04:00.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中，很多地方需要结合计时来实现，比如发送验证码每隔 1 秒钟更新界面显示，微博客户端每隔 10 分钟拉取最新微博，等等。在这种需求下，有下面几种做法可以选择<a id="more"></a>。</p><h3 id="一、NSTimer"><a href="#一、NSTimer" class="headerlink" title="一、NSTimer"></a>一、NSTimer</h3><h4 id="创建-NSTimer-实例"><a href="#创建-NSTimer-实例" class="headerlink" title="创建 NSTimer 实例"></a>创建 NSTimer 实例</h4><p>Cocoa 框架提供了 <code>NSTimer</code> 来实现这样的功能。Apple 官方对 <code>NSTimer</code> 的定义是</p><blockquote><p>You use the NSTimer class to create timer objects or, more simply, timers. A timer waits until a certain time interval has elapsed and then fires, sending a specified message to a target object.</p><p>使用 NSTimer 类来创建计时器对象。一个计时器对象会在等待一个确定的时间间隔后给一个目标实例发送特定的消息。</p></blockquote><p>如果要创建一个 <code>NSTimer</code>，最简单的做法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSTimer * nonnull)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds </div><div class="line">                                         invocation:(NSInvocation * non null)invocation </div><div class="line">                                            repeats:(BOOL)repeats</div></pre></td></tr></table></figure><p>其中 <code>seconds</code> 是延迟的时长，<code>invocation</code> 是包含相关信息的 <code>NSInvocation</code> 实例，<code>repeats</code> 表示是否重复，如果为 <code>YES</code> 则一直重复，直到手动停止。同样地，下面这个方法也可以得到一个 <code>NSTimer</code> 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (NSTimer * nonnull)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds                                        </div><div class="line">                                             target:(id nonnull)target</div><div class="line">                                           selector:(SEL nonnull)aSelector</div><div class="line">                                           userInfo:(id nullable)userInfo</div><div class="line">                                            repeats:(BOOL)repeats</div></pre></td></tr></table></figure><p>其中 <code>seconds</code>、<code>repeat</code> 的意义与上面相同。<code>target</code> 是 <code>aSelector</code> 的执行实例，<code>aSelector</code> 是发送给 <code>target</code> 的消息。需要注意的是，<code>NSTimer</code> 实例在发送 <code>aSelector</code> 时会把自己作为参数传递过去，也就是说这个方法可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)timerFireMethod:(NSTimer *)timer &#123;</div><div class="line">// 做相应的操作</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方便获取 <code>NSTimer</code> 实例，在方法中写入需要执行的代码。</p><p>由于 <code>NSTimer</code> 实例会强引用 <code>target</code>，于是在 <code>NSTimer</code> 实例与 <code>target</code> 之间产生了循环引用，所以要在释放 <code>target</code> 时释放 <code>NSTimer</code> 实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void) dealloc &#123;</div><div class="line">    [timer invalidate];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="开启计时"><a href="#开启计时" class="headerlink" title="开启计时"></a>开启计时</h4><p>使用以下方法来激活 <code>NSTimer</code> 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)fire</div></pre></td></tr></table></figure><p>需要注意的是，<code>NSTimer</code> 需要依赖于 <code>NSRunloop</code>，在 iOS 中默认只有主线程开启了 Runloop。所以如果要在其他线程这样做必须先开启对应线程的 Runloop，然后获取对应的 Runloop 实例，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode</div></pre></td></tr></table></figure><p>方法将 <code>NSTimer</code> 实例添加并激活。</p><h4 id="停止计时"><a href="#停止计时" class="headerlink" title="停止计时"></a>停止计时</h4><p>要停止已经运行中的 <code>NSTimer</code> 实例，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)invalidate</div></pre></td></tr></table></figure><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>关于 NSTimer 的内存管理，先引用一段来自 <a href="http://stackoverflow.com/questions/1449035/how-do-i-use-nstimer" target="_blank" rel="external">StackOverflow</a> 的答案</p><blockquote><p>Because the run loop maintains the timer, from the perspective of memory management there’s typically no need to keep a reference to a timer after you’ve scheduled it. Since the timer is passed as an argument when you specify its method as a selector, you can invalidate a repeating timer when appropriate within that method. In many situations, however, you also want the option of invalidating the timer—perhaps even before it starts. In this case, you do need to keep a reference to the timer, so that you can send it an invalidate message whenever appropriate. If you create an unscheduled timer (see “Unscheduled Timers”), then you must maintain a strong reference to the timer (in a reference-counted environment, you retain it) so that it is not deallocated before you use it.</p></blockquote><p>大意为 <code>NSTimer</code> 实例会被 <code>NSRunloop</code> 实例强引用，所以没有必要在其他地方再次强引用它。需要结束的时候在对应的 <code>- (void)timerFireMethod:(NSTimer *)timer</code> 里面调用 <code>- (void)invalidate</code> 即可。在被 Runloop 强引用前（即还未加入到 Runloop 中），则需要保持一个强引用来保证对它的访问。</p><blockquote><p>Setting timer to nil is for safety. The call to invalidate will result in the timer being released (by the run loop), so it is unsafe to keep a reference that points to it. Setting the local reference to nil keeps things kosher.</p></blockquote><p>最后将计时器实例置为 <code>nil</code> 是为了安全起见。<code>- (void)invalidate</code> 方法会使计时器被释放（由 Runloop 控制），如果还有对计时器的引用是不安全的。</p><h4 id="更优雅的实现"><a href="#更优雅的实现" class="headerlink" title="更优雅的实现"></a>更优雅的实现</h4><p>综合上面的讨论，可以看出还是可以通过一些技巧来使用<code>NSTimer</code>，充分利用其优点并避免造成内存问题。</p><p>后面要说的这个实现的理论依据是：</p><ul><li><code>NSTimer</code> 实例被 <code>NSRunloop</code> 实例强引用，所以它不会被提前释放，无需额外对它进行强引用；</li><li><code>NSTimer</code> 实例在发送 <code>aSelector</code> 时会把自己作为参数传递过去，所以在 <code>- (void)timerFireMethod:(NSTimer *)timer</code> 方法里面可以直接使用 <code>[timer invalidate]</code> 来结束并释放它；</li><li>初始化 <code>NSTimer</code> 时传递的 <code>target</code> 可以是 <code>__weak</code></li></ul><p>于是可以做一个名为 <code>WeakTimerTarget</code> 的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[...]</div><div class="line">@implementation WeakTimerTarget</div><div class="line">&#123;</div><div class="line">    __weak target;</div><div class="line">    SEL selector;</div><div class="line">&#125;</div><div class="line">[...]</div><div class="line">- (void)timerFireMethod:(NSTimer *)timer</div><div class="line">&#123;</div><div class="line">    if(target)</div><div class="line">    &#123;</div><div class="line">        [target performSelector:selector withObject:timer];</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        [timer invalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p><p>在初始化 <code>NSTimer</code> 实例时，使用 <code>WeakTimerTarget</code> 来代替原来的 <code>target</code>，即可做到 <code>NSTimer</code> 实例弱引用 <code>target</code>。</p><p>我的好队友 <a href="http://www.weibo.com/u/1641167047" target="_blank" rel="external">@callmewhy</a> 已经将这套逻辑封装好并开源，可以移步 <a href="https://github.com/ChatGame/HWWeakTimer" target="_blank" rel="external">GitHub: HWWeakTimer</a> 查看。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html" target="_blank" rel="external">NSTimer Class Reference</a></p><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Timers/Timers.html#//apple_ref/doc/uid/10000061i" target="_blank" rel="external">Timer Programming Topics</a></p><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i" target="_blank" rel="external">Threading Programming Guide</a></p><p><a href="http://stackoverflow.com/questions/16821736/weak-reference-to-nstimer-target-to-prevent-retain-cycle" target="_blank" rel="external">Weak Reference to NSTimer Target To Prevent Retain Cycle</a></p><h3 id="二、GCD-Timer"><a href="#二、GCD-Timer" class="headerlink" title="二、GCD Timer"></a>二、GCD Timer</h3><h4 id="创建-GCD-Timer"><a href="#创建-GCD-Timer" class="headerlink" title="创建 GCD Timer"></a>创建 GCD Timer</h4><p>除了 <code>NSTimer</code>，还可以通过 GCD 来实现计时器。GCD 中的 Timer 比较灵活，使用 dispatch source 实现，对性能的消耗低于 <code>NSTimer</code>，不需要 Runloop，也不容易导致循环引用。</p><p>先实现一个创建 GCD Timer 的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t CreateDispatchTimer(double interval, dispatch_time_t startTime, dispatch_queue_t queue, dispatch_block_t block)</div><div class="line">&#123;</div><div class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">    if (timer)</div><div class="line">    &#123;</div><div class="line">        dispatch_source_set_timer(timer, startTime, interval * NSEC_PER_SEC, (1ull * NSEC_PER_SEC) / 10);</div><div class="line">        dispatch_source_set_event_handler(timer, block);</div><div class="line">    &#125;</div><div class="line">    return timer;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后使用此方法创建 GCD Timer 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_timer = CreateDispatchTimer(secondsToFire, startTime, queue, ^&#123;</div><div class="line">// 做相应的操作</div><div class="line">  // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="开启计时-1"><a href="#开启计时-1" class="headerlink" title="开启计时"></a>开启计时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_resume(_timer);</div></pre></td></tr></table></figure><h4 id="结束计时"><a href="#结束计时" class="headerlink" title="结束计时"></a>结束计时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_source_cancel(_timer);</div></pre></td></tr></table></figure><h4 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://gist.github.com/maicki/7622108" target="_blank" rel="external">TimerWithGCD</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中，很多地方需要结合计时来实现，比如发送验证码每隔 1 秒钟更新界面显示，微博客户端每隔 10 分钟拉取最新微博，等等。在这种需求下，有下面几种做法可以选择
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Method Swizzling</title>
    <link href="http://tzuyangliu.github.io/2015/04/03/objc-use-method-swizzling/"/>
    <id>http://tzuyangliu.github.io/2015/04/03/objc-use-method-swizzling/</id>
    <published>2015-04-02T20:52:00.000Z</published>
    <updated>2017-01-23T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Objective-C 中，类的方法列表与方法实现存在映射关系，类的方法以叫做 <code>IMP</code> 的函数指针来指向具体的实现函数<a id="more"></a>。其中 <code>IMP</code> 指针定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id (* IMP) (id, SEL, ...)</div></pre></td></tr></table></figure></p><p>一般的 selector 映射表：<br><img src="http://7xkkiq.com1.z0.glb.clouddn.com/objective-c-method-swizzling-1.png" alt=""><br>由于 Objective-C 动态语言的特性，在 <code>objc/runtime.h</code> 头文件中提供了一些方法来操作（新增，交换，修改）这张表，这样的操作称为 Method Swizzling，方法调配。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p> 在某个类中新增某个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</div></pre></td></tr></table></figure></p><p>交换两个方法的 <code>IMP</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void method_exchangeImplementations(Method m1, Method m2)</div></pre></td></tr></table></figure></p><p>修改某个类的对应 <code>SEL</code> 的 <code>IMP</code>（返回值为旧 <code>IMP</code> ）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMP class_replaceMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const char *types)</div><div class="line">//或</div><div class="line">IMP method_setImplementation(Method m, IMP imp)</div></pre></td></tr></table></figure></p><p>通过上面这些方法，可以实现替换 <code>SEL</code> 的 <code>IMP</code>。比如我对上面提到的映射表的两个 <code>SEL</code> 互换 <code>IMP</code>：<br><img src="http://7xkkiq.com1.z0.glb.clouddn.com/objective-c-method-swizzling-2.png" alt=""><br>在交换之后，当我执行 B 方法时，真正执行的是 IMPc 的代码。从这里可以看出 Method Swizzling 的强大之处，不需要重新编写子类，修改 <code>SEL</code> 表的映射即可对相应类的实例的行为进行修改。</p><p>那么，这样做的意义在哪里？很明显，当我们只知道头文件而不知道具体的实现时（如闭源的 Cocoa 框架），可以通过 Method Swizzling 来对这些类方法或实例进行修改，在不修改源码的前提下改变了类的行为。这算是 Objective-C 的一个 hook 方案，不过在日常的代码中这种做法更适合在调试时实现对闭源方法的日志记录。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>如果要记录 <code>NSArray</code> 实例的 firstObject 方法的调用情况。首先，定义一个 <code>NSArray</code> 的 Category，名为 MethodSwizzling：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//头文件</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface NSArray (MethodSwizzling)</div><div class="line">- (id)my_firstObject;</div><div class="line">@end</div><div class="line">//实现</div><div class="line">#import &quot;NSArray+MethodSwizzling.h&quot;</div><div class="line">@implementation NSArray (MethodSwizzling)</div><div class="line">- (id)my_firstObject&#123;</div><div class="line">    id object = [self my_firstObject];</div><div class="line">    NSLog(@&quot;Method called : [%@ firstObject]&quot;, [self class]);</div><div class="line">    return object;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p><p>有一点需要注意的就是，在 my_firstObject 方法中看起来存在死循环。不过这是为了后面做铺垫，因为当完成方法实现交换后， firstObject 方法才会真正调用 my_firstObject 的实现，不会出现死循环的情况。</p><p>然后在使用的代码中导入 <code>objc/runtime.h</code> 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div></pre></td></tr></table></figure></p><p>交换 Category 里面声明的方法与要记录的方法实现，即 my_firstObject 与 firstObject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Method lastMethod = class_getInstanceMethod([NSArray class], @selector(firstObject));</div><div class="line">Method newMethod = class_getInstanceMethod([NSArray class], @selector(my_firstObject));</div><div class="line">method_exchangeImplementations(lastMethod, newMethod);</div></pre></td></tr></table></figure></p><p>至此已经完成了对方法实现的交换。然后就可以测试查看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@1, @2];</div><div class="line">[array firstObject];</div><div class="line">//输出结果：Method called : [__NSArrayI firstObject]</div></pre></td></tr></table></figure></p><p>可以看到实现了对 <code>NSArray</code> 实例 firstObject 方法调用的记录。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>我也尝试对 <code>NSNumber</code> 实例的 integerValue 等方法实现进行交换，结果发现通过 Category 写的方法实现在交换后并不能成功被调用。我目前的结论是因为 <code>NSNumber</code> 是一个类簇，用于初始化的工厂方法隐藏了很多子类的细节，而真正被交换的实例的类是通过动态的 <code>+ (BOOL)resolveInstanceMethod:(SEL)name</code> 方法来获取结果而非写好的实现，这一点等我后面完成对类簇的研究后再回来讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Objective-C 中，类的方法列表与方法实现存在映射关系，类的方法以叫做 &lt;code&gt;IMP&lt;/code&gt; 的函数指针来指向具体的实现函数
    
    </summary>
    
    
  </entry>
  
</feed>
